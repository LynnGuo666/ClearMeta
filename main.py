import os
import sys
import shutil
import threading
import queue
import traceback
from concurrent.futures import ThreadPoolExecutor, as_completed
from dataclasses import dataclass
from pathlib import Path
from typing import List, Optional, Tuple

try:
    from PyQt5.QtWidgets import (
        QApplication, QMainWindow, QVBoxLayout, QHBoxLayout, QWidget,
        QPushButton, QListWidget, QProgressBar, QLabel, QCheckBox,
        QLineEdit, QTextEdit, QFileDialog, QMessageBox, QGroupBox,
        QSplitter, QTabWidget, QTreeWidget, QTreeWidgetItem, QComboBox
    )
    from PyQt5.QtCore import QThread, pyqtSignal, Qt, QUrl
    from PyQt5.QtGui import QFont, QDragEnterEvent, QDropEvent, QPixmap
    QT_AVAILABLE = True
except Exception:  # Missing PyQt5
    QT_AVAILABLE = False
    QApplication = QMainWindow = QWidget = None  # type: ignore

from PIL import Image, ImageOps, PngImagePlugin
import piexif


APP_NAME = "ClearMeta - AIå›¾ç‰‡å…ƒæ•°æ®æ¸…ç†å™¨"
APP_VERSION = "Beta 1.2.0"
APP_AUTHOR = "Lynn"
SUPPORTED_EXTS = {".jpg", ".jpeg", ".png", ".webp", ".tif", ".tiff", ".bmp"}

# AIç”Ÿæˆå›¾ç‰‡å¸¸è§çš„å…ƒæ•°æ®æ ‡è¯†
AI_GENERATED_MARKERS = {
    # å¸¸è§AIç”Ÿæˆå·¥å…·æ ‡è¯†
    'software': [
        'midjourney', 'dall-e', 'dalle', 'stable diffusion', 'stablediffusion',
        'novelai', 'waifu2x', 'real-esrgan', 'esrgan', 'topaz', 'adobe firefly',
        'canva', 'leonardo.ai', 'artbreeder', 'runwayml', 'deepart', 'prisma',
        'lensa', 'wombo', 'crayon', 'nightcafe', 'artstation', 'jasper art',
        'fotor', 'photosonic', 'starryai', 'deepdreamgenerator', 'aiç”»å®¶',
        'disco diffusion', 'imagen', 'parti', 'flamingo', 'phenaki',
        'comfyui', 'automatic1111', 'invokeai', 'fooocus'
    ],
    # æç¤ºè¯ç›¸å…³å­—æ®µ
    'prompt_fields': [
        'prompt', 'negative prompt', 'seed', 'steps', 'cfg scale', 'sampler',
        'model', 'checkpoint', 'lora', 'controlnet', 'vae', 'clip skip',
        'denoising strength', 'hires upscale', 'upscaler', 'face restoration',
        'parameters', 'generation_data', 'ai_info', 'generation_info'
    ],
    # æè¿°æ€§å­—æ®µä¸­çš„AIæ ‡è¯†
    'description_markers': [
        'generated by', 'created with', 'ai generated', 'ai created',
        'artificial intelligence', 'neural network', 'machine learning',
        'deep learning', 'gan', 'diffusion', 'transformer', 'äººå·¥æ™ºèƒ½',
        'aiç»˜ç”»', 'aiä½œç”»', 'æœºå™¨å­¦ä¹ ', 'æ·±åº¦å­¦ä¹ ', 'ç¥ç»ç½‘ç»œ'
    ]
}


def detect_ai_generated_metadata(file_path: Path) -> tuple[bool, list]:
    """æ£€æµ‹æ˜¯å¦ä¸ºAIç”Ÿæˆå›¾ç‰‡ï¼Œè¿”å›(æ˜¯å¦AIç”Ÿæˆ, æ£€æµ‹åˆ°çš„æ ‡è¯†åˆ—è¡¨)"""
    detected_markers = []
    
    try:
        with Image.open(str(file_path)) as img:
            # æ£€æŸ¥åŸºæœ¬ä¿¡æ¯
            if hasattr(img, 'info'):
                for key, value in img.info.items():
                    key_lower = str(key).lower()
                    value_str = str(value).lower()
                    
                    # æ£€æŸ¥è½¯ä»¶æ ‡è¯†
                    for marker in AI_GENERATED_MARKERS['software']:
                        if marker in key_lower or marker in value_str:
                            detected_markers.append(f"Software: {marker}")
                    
                    # æ£€æŸ¥æç¤ºè¯å­—æ®µ
                    for field in AI_GENERATED_MARKERS['prompt_fields']:
                        if field in key_lower:
                            detected_markers.append(f"Prompt field: {key}")
                    
                    # æ£€æŸ¥æè¿°æ€§æ ‡è¯†
                    for desc_marker in AI_GENERATED_MARKERS['description_markers']:
                        if desc_marker in value_str:
                            detected_markers.append(f"Description: {desc_marker}")
            
            # æ£€æŸ¥EXIFæ•°æ®
            try:
                exif_dict = piexif.load(str(file_path))
                for ifd_name, ifd in exif_dict.items():
                    if ifd_name == "thumbnail" or not ifd:
                        continue
                    for tag_id, value in ifd.items():
                        if isinstance(value, bytes):
                            try:
                                value_str = value.decode('utf-8', errors='ignore').lower()
                            except:
                                continue
                        else:
                            value_str = str(value).lower()
                        
                        # æ£€æŸ¥AIæ ‡è¯†
                        for marker in AI_GENERATED_MARKERS['software']:
                            if marker in value_str:
                                detected_markers.append(f"EXIF: {marker}")
                        
                        for desc_marker in AI_GENERATED_MARKERS['description_markers']:
                            if desc_marker in value_str:
                                detected_markers.append(f"EXIF: {desc_marker}")
            except:
                pass
    
    except Exception:
        pass
    
    # å»é‡
    detected_markers = list(set(detected_markers))
    is_ai_generated = len(detected_markers) > 0
    
    return is_ai_generated, detected_markers


def extract_exif_info(file_path: Path) -> dict:
    """Extract EXIF information from image file."""
    info = {}
    try:
        with Image.open(str(file_path)) as img:
            # Basic image info
            info['æ–‡ä»¶å¤§å°'] = f"{file_path.stat().st_size / 1024:.1f} KB"
            info['å›¾ç‰‡å°ºå¯¸'] = f"{img.width} x {img.height}"
            info['é¢œè‰²æ¨¡å¼'] = img.mode
            info['æ ¼å¼'] = img.format or "Unknown"
            
            # AIç”Ÿæˆæ£€æµ‹
            is_ai, ai_markers = detect_ai_generated_metadata(file_path)
            if is_ai:
                info['ğŸ¤– AIç”Ÿæˆæ£€æµ‹'] = "æ˜¯"
                info['ğŸ” æ£€æµ‹åˆ°çš„AIæ ‡è¯†'] = "; ".join(ai_markers)
            else:
                info['ğŸ¤– AIç”Ÿæˆæ£€æµ‹'] = "å¦"
            
            # PNG info (å¸¸åŒ…å«AIç”Ÿæˆä¿¡æ¯)
            if hasattr(img, 'info') and img.info:
                for key, value in img.info.items():
                    key_str = str(key)
                    if isinstance(value, bytes):
                        try:
                            value = value.decode('utf-8', errors='ignore')
                        except:
                            value = f"<{len(value)} bytes>"
                    info[f"PNG_{key_str}"] = str(value)[:200] + ("..." if len(str(value)) > 200 else "")
            
            # EXIF data
            if hasattr(img, '_getexif') and img._getexif():
                exif_dict = img._getexif()
                for tag_id, value in exif_dict.items():
                    tag = piexif.TAGS.get(tag_id, tag_id)
                    if isinstance(value, bytes):
                        try:
                            value = value.decode('utf-8', errors='ignore')
                        except:
                            value = str(value)
                    info[f"EXIF_{tag}"] = str(value)
            
            # Try piexif for more detailed EXIF
            try:
                exif_dict = piexif.load(str(file_path))
                for ifd_name, ifd in exif_dict.items():
                    if ifd_name == "thumbnail" or not ifd:
                        continue
                    for tag_id, value in ifd.items():
                        tag_name = piexif.TAGS.get(ifd_name, {}).get(tag_id, f"Tag_{tag_id}")
                        if isinstance(value, bytes):
                            try:
                                value = value.decode('utf-8', errors='ignore')
                            except:
                                value = f"<{len(value)} bytes>"
                        info[f"{ifd_name}_{tag_name}"] = str(value)
            except:
                pass
                
    except Exception as e:
        info['é”™è¯¯'] = str(e)
    
    return info


def _has_exiftool() -> Optional[str]:
	"""Return exiftool path if available, else None."""
	return shutil.which("exiftool")


def _has_ffmpeg() -> Optional[str]:
	"""Return ffmpeg path if available, else None."""
	return shutil.which("ffmpeg")


def _ensure_parent_dir(path: Path) -> None:
	path.parent.mkdir(parents=True, exist_ok=True)


def _ffmpeg_clean_metadata(input_path: Path, output_path: Path, output_format: str = "åŸæ ¼å¼") -> Tuple[bool, str]:
	"""Use FFmpeg to clean metadata from image files with optional format conversion."""
	ffmpeg = _has_ffmpeg()
	if not ffmpeg:
		return False, "FFmpeg not found"
	
	try:
		import subprocess
		_ensure_parent_dir(output_path)
		
		# æ ¹æ®è¾“å‡ºæ ¼å¼è°ƒæ•´è¾“å‡ºè·¯å¾„å’Œç¼–ç å‚æ•°
		if output_format == "JPG":
			output_path = output_path.with_suffix('.jpg')
			codec_params = ["-c:v", "mjpeg", "-q:v", "2"]  # é«˜è´¨é‡JPEG
		elif output_format == "PNG":
			output_path = output_path.with_suffix('.png')
			codec_params = ["-c:v", "png", "-compression_level", "6"]
		else:  # åŸæ ¼å¼
			ext = input_path.suffix.lower()
			if ext in ['.jpg', '.jpeg']:
				codec_params = ["-c:v", "copy"]  # ä¿æŒåŸå§‹è´¨é‡
			elif ext == '.png':
				codec_params = ["-c:v", "png", "-compression_level", "6"]
			elif ext == '.webp':
				codec_params = ["-c:v", "libwebp", "-quality", "95"]
			elif ext in ['.tif', '.tiff']:
				codec_params = ["-c:v", "tiff", "-compression_algo", "lzw"]
			elif ext == '.bmp':
				codec_params = ["-c:v", "bmp"]
			else:
				codec_params = ["-c:v", "copy"]
		
		# æ„å»º FFmpeg å‘½ä»¤
		cmd = [
			ffmpeg,
			"-i", str(input_path),
			"-map_metadata", "-1",  # ç§»é™¤æ‰€æœ‰å…ƒæ•°æ®
		] + codec_params + [
			"-y",  # è¦†ç›–è¾“å‡ºæ–‡ä»¶
			str(output_path)
		]
		
		result = subprocess.run(
			cmd, 
			stdout=subprocess.PIPE, 
			stderr=subprocess.PIPE, 
			text=True,
			timeout=60
		)
		
		if result.returncode == 0:
			format_info = f" -> {output_format}" if output_format != "åŸæ ¼å¼" else ""
			return True, f"FFmpegæ¸…ç†æˆåŠŸ{format_info}"
		else:
			return False, f"FFmpegé”™è¯¯: {result.stderr}"
			
	except subprocess.TimeoutExpired:
		return False, "FFmpegå¤„ç†è¶…æ—¶"
	except Exception as e:
		return False, f"FFmpegå¼‚å¸¸: {str(e)}"


def _pil_resave_strip_metadata_with_format(inp: Path, outp: Path, output_format: str = "åŸæ ¼å¼") -> None:
	"""Fallback: re-save via Pillow to drop metadata with optional format conversion."""
	with Image.open(str(inp)) as im:
		im = ImageOps.exif_transpose(im)
		
		# æ ¹æ®è¾“å‡ºæ ¼å¼è®¾ç½®å‚æ•°
		if output_format == "JPG":
			# è½¬æ¢ä¸º RGB æ¨¡å¼ä»¥æ”¯æŒ JPEG
			if im.mode in ("RGBA", "LA", "P"):
				rgb_img = Image.new("RGB", im.size, (255, 255, 255))
				if im.mode == "P":
					im = im.convert("RGBA")
				if im.mode in ("RGBA", "LA"):
					rgb_img.paste(im, mask=im.split()[-1])
				im = rgb_img
			elif im.mode not in ("RGB", "L"):
				im = im.convert("RGB")
			fmt = "JPEG"
			params = {"quality": 95, "optimize": True}
		elif output_format == "PNG":
			fmt = "PNG"
			pnginfo = PngImagePlugin.PngInfo()
			params = {"pnginfo": pnginfo, "optimize": True}
		else:  # åŸæ ¼å¼
			fmt = (im.format or inp.suffix.replace('.', '').upper())
			fmt = (fmt or "").upper()
			if fmt == "JPG":
				fmt = "JPEG"
			if fmt == "TIF":
				fmt = "TIFF"
			params = {}

			if fmt.upper() in {"JPEG", "JPG"}:
				params.update({"quality": 95, "optimize": True})
			elif fmt.upper() == "PNG":
				pnginfo = PngImagePlugin.PngInfo()
				params.update({"pnginfo": pnginfo, "optimize": True})
			elif fmt.upper() == "WEBP":
				params.update({"quality": 95, "method": 6})
			elif fmt.upper() in {"TIFF", "TIF"}:
				params.update({"compression": "tiff_deflate"})

		_ensure_parent_dir(outp)
		im.save(str(outp), fmt, **params)


def _pil_resave_strip_metadata(inp: Path, outp: Path) -> None:
	"""Fallback: re-save via Pillow to drop metadata across common formats.

	- Auto-apply orientation (so removing EXIF Orientation doesn't rotate unexpectedly)
	- Remove EXIF, XMP, IPTC by not passing them through
	- PNG: remove text chunks; JPEG/TIFF: avoid embedding exif
	"""
	_pil_resave_strip_metadata_with_format(inp, outp, "åŸæ ¼å¼")


def _piexif_strip_if_needed(outp: Path) -> None:
	"""For JPEG/TIFF ensure EXIF is removed using piexif as a second pass."""
	try:
		if outp.suffix.lower() in {".jpg", ".jpeg", ".tif", ".tiff"}:
			# piexif.remove modifies in place. Work on a temp copy then replace to be safe.
			piexif.remove(str(outp))
	except Exception:
		# Non-fatal; Pillow save likely removed EXIF already
		pass


def clean_one_image(
	input_path: Path,
	output_path: Path,
	prefer_ffmpeg: bool = True,
	output_format: str = "åŸæ ¼å¼",
) -> Tuple[bool, str]:
	"""Clean metadata from a single image file with enhanced AI metadata removal using FFmpeg.

	Returns (ok, message).
	"""
	try:
		# å…ˆæ£€æµ‹æ˜¯å¦ä¸ºAIç”Ÿæˆå›¾ç‰‡
		is_ai, ai_markers = detect_ai_generated_metadata(input_path)
		ai_info = f" (æ£€æµ‹åˆ°AIç”Ÿæˆ: {len(ai_markers)}ä¸ªæ ‡è¯†)" if is_ai else ""
		
		# æ ¹æ®è¾“å‡ºæ ¼å¼è°ƒæ•´è¾“å‡ºè·¯å¾„
		if output_format == "JPG":
			output_path = output_path.with_suffix('.jpg')
		elif output_format == "PNG":
			output_path = output_path.with_suffix('.png')
		
		# æ–¹æ³•1: ä¼˜å…ˆä½¿ç”¨ FFmpeg (æœ€å¼ºå¤§çš„å…ƒæ•°æ®æ¸…ç†ï¼Œæ”¯æŒæ ¼å¼è½¬æ¢)
		if prefer_ffmpeg and _has_ffmpeg():
			success, msg = _ffmpeg_clean_metadata(input_path, output_path, output_format)
			if success:
				return True, f"FFmpegæ¸…ç†: {input_path.name}{ai_info}"
			# FFmpeg å¤±è´¥åˆ™ç»§ç»­å°è¯•å…¶ä»–æ–¹æ³•
		
		# æ–¹æ³•2: ä½¿ç”¨ exiftool ä½œä¸ºå¤‡é€‰ (ä¸æ”¯æŒæ ¼å¼è½¬æ¢)
		if _has_exiftool() and output_format == "åŸæ ¼å¼":
			_ensure_parent_dir(output_path)
			import subprocess

			cmd = [_has_exiftool(), "-all=", "-o", str(output_path), str(input_path)]
			res = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
			if res.returncode == 0:
				return True, f"exiftoolæ¸…ç†: {input_path.name}{ai_info}"
		
		# æ–¹æ³•3: ä½¿ç”¨ Python/Pillow (æ”¯æŒæ ¼å¼è½¬æ¢)
		_pil_resave_strip_metadata_with_format(input_path, output_path, output_format)
		_piexif_strip_if_needed(output_path)
		format_info = f" -> {output_format}" if output_format != "åŸæ ¼å¼" else ""
		return True, f"Pythonæ¸…ç†: {input_path.name}{ai_info}{format_info}"

	except Exception as e:
		return False, f"æ¸…ç†å¤±è´¥: {input_path.name} -> {e}"


def gather_images(paths: List[Path]) -> List[Path]:
	files: List[Path] = []
	for p in paths:
		if p.is_dir():
			for root, _, fnames in os.walk(p):
				for fn in fnames:
					ext = Path(fn).suffix.lower()
					if ext in SUPPORTED_EXTS:
						files.append(Path(root) / fn)
		else:
			if p.suffix.lower() in SUPPORTED_EXTS:
				files.append(p)
	# de-dup while preserving order
	seen = set()
	out = []
	for f in files:
		if f not in seen:
			seen.add(f)
			out.append(f)
	return out


# --------------------------- GUI ---------------------------


class WorkerThread(QThread):
    """Background thread for processing images."""
    progress = pyqtSignal(int)
    log_message = pyqtSignal(str)
    finished_job = pyqtSignal(int, int)  # successes, failures

    def __init__(self, files, config):
        super().__init__()
        self.files = files
        self.config = config

    def run(self):
        successes = 0
        failures = 0
        try:
            with ThreadPoolExecutor(max_workers=self.config.workers) as ex:
                fut_to_file = {}
                for i, f in enumerate(self.files):
                    if self.config.overwrite:
                        out = f
                    else:
                        out_base = self.config.output_dir or f.parent
                        out = out_base / f.name
                    fut = ex.submit(clean_one_image, f, out, self.config.use_ffmpeg, self.config.output_format)
                    fut_to_file[fut] = (f, i)

                for fut in as_completed(fut_to_file):
                    f, i = fut_to_file[fut]
                    ok, msg = fut.result()
                    self.log_message.emit(msg)
                    if ok:
                        successes += 1
                    else:
                        failures += 1
                    self.progress.emit(i + 1)
        except Exception:
            self.log_message.emit("å‘ç”Ÿé”™è¯¯:\n" + traceback.format_exc())
        finally:
            self.finished_job.emit(successes, failures)


@dataclass
class JobConfig:
    overwrite: bool
    output_dir: Optional[Path]
    use_ffmpeg: bool
    output_format: str = "åŸæ ¼å¼"  # "åŸæ ¼å¼", "JPG", "PNG"
    workers: int = 4


if QT_AVAILABLE:
    class ClearMetaApp(QMainWindow):
        def __init__(self):
            super().__init__()
            self.setWindowTitle(f"{APP_NAME} {APP_VERSION}")
            self.setGeometry(100, 100, 1200, 800)  # Larger window for EXIF viewer
            
            self.selected_files: List[Path] = []
            self.worker_thread = None
            
            # Enable drag and drop
            self.setAcceptDrops(True)
            
            self.setup_ui()

        def dragEnterEvent(self, event: QDragEnterEvent):
            """Handle drag enter event"""
            if event.mimeData().hasUrls():
                event.accept()
            else:
                event.ignore()

        def dropEvent(self, event: QDropEvent):
            """Handle drop event"""
            files = []
            for url in event.mimeData().urls():
                if url.isLocalFile():
                    file_path = url.toLocalFile()
                    files.append(Path(file_path))
            
            if files:
                self.append_files(files)
                self.log(f"é€šè¿‡æ‹–æ‹½æ·»åŠ äº† {len(files)} ä¸ªé¡¹ç›®")
            
            event.accept()

        def setup_ui(self):
            central_widget = QWidget()
            self.setCentralWidget(central_widget)
            layout = QVBoxLayout(central_widget)

            # Top controls
            controls_group = QGroupBox("æ§åˆ¶")
            controls_layout = QVBoxLayout(controls_group)
            
            # Buttons row
            button_layout = QHBoxLayout()
            self.add_files_btn = QPushButton("æ·»åŠ å›¾ç‰‡")
            self.add_folder_btn = QPushButton("æ·»åŠ æ–‡ä»¶å¤¹")
            self.clear_btn = QPushButton("æ¸…ç©ºåˆ—è¡¨")
            
            self.add_files_btn.clicked.connect(self.add_files)
            self.add_folder_btn.clicked.connect(self.add_folder)
            self.clear_btn.clicked.connect(self.clear_list)
            
            button_layout.addWidget(self.add_files_btn)
            button_layout.addWidget(self.add_folder_btn)
            button_layout.addWidget(self.clear_btn)
            button_layout.addStretch()
            
            # Options row
            options_layout = QHBoxLayout()
            self.overwrite_cb = QCheckBox("è¦†ç›–åŸæ–‡ä»¶")
            self.use_ffmpeg_cb = QCheckBox("ä¼˜å…ˆä½¿ç”¨ FFmpegï¼ˆæœ€å¼ºå¤§çš„å…ƒæ•°æ®æ¸…ç†ï¼‰")
            # é»˜è®¤å¯ç”¨ FFmpegï¼Œå¦‚æœå¯ç”¨çš„è¯
            self.use_ffmpeg_cb.setChecked(True)
            
            # è¾“å‡ºæ ¼å¼é€‰æ‹©
            self.format_combo = QComboBox()
            self.format_combo.addItems(["åŸæ ¼å¼", "JPG", "PNG"])
            self.format_combo.setCurrentText("åŸæ ¼å¼")
            
            self.overwrite_cb.toggled.connect(self.toggle_output_dir)
            
            options_layout.addWidget(self.overwrite_cb)
            options_layout.addWidget(self.use_ffmpeg_cb)
            options_layout.addWidget(QLabel("è¾“å‡ºæ ¼å¼:"))
            options_layout.addWidget(self.format_combo)
            options_layout.addStretch()
            
            # Output directory row
            output_layout = QHBoxLayout()
            self.output_entry = QLineEdit()
            self.output_browse_btn = QPushButton("é€‰æ‹©è¾“å‡ºç›®å½•")
            self.output_browse_btn.clicked.connect(self.choose_output_dir)
            
            output_layout.addWidget(QLabel("è¾“å‡ºç›®å½•:"))
            output_layout.addWidget(self.output_entry)
            output_layout.addWidget(self.output_browse_btn)
            
            controls_layout.addLayout(button_layout)
            controls_layout.addLayout(options_layout)
            controls_layout.addLayout(output_layout)
            
            # File list with EXIF viewer
            main_splitter = QSplitter(Qt.Horizontal)
            
            # Left side: File list
            left_widget = QWidget()
            left_layout = QVBoxLayout(left_widget)
            
            list_group = QGroupBox("å›¾ç‰‡åˆ—è¡¨ï¼ˆæ”¯æŒæ‹–æ‹½æ–‡ä»¶æˆ–æ–‡ä»¶å¤¹åˆ°æ­¤å¤„ï¼‰")
            list_layout = QVBoxLayout(list_group)
            self.file_list = QListWidget()
            # Enable drag and drop for the list widget too
            self.file_list.setAcceptDrops(True)
            self.file_list.dragEnterEvent = self.dragEnterEvent
            self.file_list.dropEvent = self.dropEvent
            self.file_list.currentItemChanged.connect(self.on_file_selected)
            list_layout.addWidget(self.file_list)
            left_layout.addWidget(list_group)
            
            # Right side: EXIF info
            right_widget = QWidget()
            right_layout = QVBoxLayout(right_widget)
            
            exif_group = QGroupBox("EXIF ä¿¡æ¯")
            exif_layout = QVBoxLayout(exif_group)
            self.exif_tree = QTreeWidget()
            self.exif_tree.setHeaderLabels(["å±æ€§", "å€¼"])
            self.exif_tree.setAlternatingRowColors(True)
            self.exif_tree.setRootIsDecorated(False)
            exif_layout.addWidget(self.exif_tree)
            right_layout.addWidget(exif_group)
            
            main_splitter.addWidget(left_widget)
            main_splitter.addWidget(right_widget)
            main_splitter.setStretchFactor(0, 2)  # File list takes 2/3
            main_splitter.setStretchFactor(1, 1)  # EXIF info takes 1/3
            
            # Progress and action buttons
            action_layout = QHBoxLayout()
            self.progress_bar = QProgressBar()
            self.status_label = QLabel("å°±ç»ª")
            self.start_btn = QPushButton("å¼€å§‹æ¸…ç†")
            self.open_output_btn = QPushButton("æ‰“å¼€è¾“å‡ºç›®å½•")
            
            self.start_btn.clicked.connect(self.start_clean)
            self.open_output_btn.clicked.connect(self.open_output)
            
            action_layout.addWidget(self.progress_bar)
            action_layout.addWidget(self.status_label)
            action_layout.addWidget(self.start_btn)
            action_layout.addWidget(self.open_output_btn)
            
            # Bottom tabs for log and sponsor
            bottom_tabs = QTabWidget()
            
            # Log tab
            log_widget = QWidget()
            log_layout = QVBoxLayout(log_widget)
            self.log_text = QTextEdit()
            self.log_text.setMaximumHeight(120)
            log_layout.addWidget(self.log_text)
            bottom_tabs.addTab(log_widget, "æ—¥å¿—")
            
            # Sponsor tab
            sponsor_widget = QWidget()
            sponsor_layout = QHBoxLayout(sponsor_widget)
            
            # QR code image
            self.qr_label = QLabel()
            self.qr_label.setAlignment(Qt.AlignCenter)
            self.qr_label.setFixedSize(100, 100)
            self.qr_label.setStyleSheet("border: 1px solid gray;")
            
            # Load QR code if exists
            qr_path = Path("sponsor_qr.png")
            if qr_path.exists():
                pixmap = QPixmap(str(qr_path))
                scaled_pixmap = pixmap.scaled(100, 100, Qt.KeepAspectRatio, Qt.SmoothTransformation)
                self.qr_label.setPixmap(scaled_pixmap)
            else:
                self.qr_label.setText("äºŒç»´ç \n(è¯·æ”¾ç½®\nsponsor_qr.png)")
            
            # Sponsor text
            sponsor_text = QLabel("å¦‚æœè¿™ä¸ªå·¥å…·å¯¹æ‚¨æœ‰å¸®åŠ©ï¼Œ\næ¬¢è¿æ‰«ç èµåŠ©æ”¯æŒå¼€å‘ï¼")
            sponsor_text.setAlignment(Qt.AlignCenter)
            
            # About info
            about_text = QLabel(f"å…³äº\n\nä½œè€…: {APP_AUTHOR}\nç‰ˆæœ¬: {APP_VERSION}\n\nä¸€ä¸ªç®€å•æ˜“ç”¨çš„\nå›¾ç‰‡å…ƒæ•°æ®æ¸…ç†å·¥å…·")
            about_text.setAlignment(Qt.AlignCenter)
            about_text.setStyleSheet("color: #666; font-size: 11px; padding: 10px;")
            
            sponsor_layout.addStretch()
            sponsor_layout.addWidget(self.qr_label)
            sponsor_layout.addWidget(sponsor_text)
            sponsor_layout.addWidget(about_text)
            sponsor_layout.addStretch()
            
            bottom_tabs.addTab(sponsor_widget, "èµåŠ©æ”¯æŒ")
            
            # Add all to main layout
            layout.addWidget(controls_group)
            layout.addWidget(main_splitter, 1)  # Main content takes most space
            layout.addLayout(action_layout)
            layout.addWidget(bottom_tabs)
            
            self.toggle_output_dir()

        def toggle_output_dir(self):
            self.output_entry.setEnabled(not self.overwrite_cb.isChecked())
            self.output_browse_btn.setEnabled(not self.overwrite_cb.isChecked())

        def choose_output_dir(self):
            dir_path = QFileDialog.getExistingDirectory(self, "é€‰æ‹©è¾“å‡ºç›®å½•")
            if dir_path:
                self.output_entry.setText(dir_path)

        def add_files(self):
            files, _ = QFileDialog.getOpenFileNames(
                self, "é€‰æ‹©å›¾ç‰‡",
                filter="å›¾ç‰‡ (*.jpg *.jpeg *.png *.webp *.tif *.tiff *.bmp);;æ‰€æœ‰æ–‡ä»¶ (*)"
            )
            if files:
                self.append_files([Path(f) for f in files])

        def add_folder(self):
            dir_path = QFileDialog.getExistingDirectory(self, "é€‰æ‹©æ–‡ä»¶å¤¹")
            if dir_path:
                self.append_files([Path(dir_path)])

        def append_files(self, paths: List[Path]):
            imgs = gather_images(paths)
            added = 0
            for p in imgs:
                if p not in self.selected_files:
                    self.selected_files.append(p)
                    # æ£€æµ‹AIç”Ÿæˆæ ‡è¯†
                    is_ai, ai_markers = detect_ai_generated_metadata(p)
                    display_name = str(p)
                    if is_ai:
                        display_name = f"ğŸ¤– {display_name}"
                    self.file_list.addItem(display_name)
                    added += 1
            if added:
                self.log(f"æ·»åŠ  {added} ä¸ªæ–‡ä»¶")
                # å¦‚æœæœ‰AIç”Ÿæˆå›¾ç‰‡ï¼Œæ·»åŠ æç¤º
                ai_count = sum(1 for p in self.selected_files if detect_ai_generated_metadata(p)[0])
                if ai_count > 0:
                    self.log(f"æ£€æµ‹åˆ° {ai_count} ä¸ªAIç”Ÿæˆå›¾ç‰‡ ğŸ¤–")

        def clear_list(self):
            self.selected_files.clear()
            self.file_list.clear()
            self.exif_tree.clear()

        def on_file_selected(self, current, previous):
            """Handle file selection and show EXIF info."""
            self.exif_tree.clear()
            
            if current is None:
                return
                
            current_row = self.file_list.row(current)
            if 0 <= current_row < len(self.selected_files):
                file_path = self.selected_files[current_row]
                
                # Extract and display EXIF info
                exif_info = extract_exif_info(file_path)
                
                for key, value in exif_info.items():
                    item = QTreeWidgetItem([key, str(value)])
                    self.exif_tree.addTopLevelItem(item)
                
                # Auto-resize columns
                self.exif_tree.resizeColumnToContents(0)
                self.exif_tree.resizeColumnToContents(1)

        def start_clean(self):
            if not self.selected_files:
                QMessageBox.information(self, APP_NAME, "è¯·å…ˆæ·»åŠ å›¾ç‰‡æˆ–æ–‡ä»¶å¤¹")
                return

            overwrite = self.overwrite_cb.isChecked()
            out_dir = Path(self.output_entry.text()) if self.output_entry.text().strip() else None
            if not overwrite and not out_dir:
                QMessageBox.warning(self, APP_NAME, "æœªå‹¾é€‰è¦†ç›–åŸæ–‡ä»¶ä¸”æœªè®¾ç½®è¾“å‡ºç›®å½•")
                return

            config = JobConfig(
                overwrite=overwrite,
                output_dir=out_dir,
                use_ffmpeg=self.use_ffmpeg_cb.isChecked(),
                output_format=self.format_combo.currentText(),
            )

            self.progress_bar.setMaximum(len(self.selected_files))
            self.progress_bar.setValue(0)
            self.status_label.setText(f"0/{len(self.selected_files)}")
            self.log("å¼€å§‹æ¸…ç†â€¦")
            self.start_btn.setEnabled(False)

            self.worker_thread = WorkerThread(self.selected_files, config)
            self.worker_thread.progress.connect(self.update_progress)
            self.worker_thread.log_message.connect(self.log)
            self.worker_thread.finished_job.connect(self.job_finished)
            self.worker_thread.start()

        def update_progress(self, value):
            self.progress_bar.setValue(value)
            self.status_label.setText(f"{value}/{len(self.selected_files)}")

        def job_finished(self, successes, failures):
            self.log(f"å®Œæˆ: æˆåŠŸ {successes}, å¤±è´¥ {failures}")
            self.start_btn.setEnabled(True)
            self.worker_thread = None

        def open_output(self):
            target = self.output_entry.text() or (str(self.selected_files[0].parent) if self.selected_files else None)
            if not target:
                return
            path = Path(target)
            if sys.platform.startswith("darwin"):
                os.system(f"open '{path}'")
            elif os.name == "nt":
                os.startfile(path)  # type: ignore[attr-defined]
            else:
                os.system(f"xdg-open '{path}'")

        def log(self, text: str):
            self.log_text.append(text)
            # Auto scroll to bottom
            scrollbar = self.log_text.verticalScrollBar()
            scrollbar.setValue(scrollbar.maximum())

else:
    class ClearMetaApp:  # minimal placeholder for headless imports/tests
        pass
def main():
    if not QT_AVAILABLE:
        print("PyQt5 ä¸å¯ç”¨ï¼ŒGUI æ— æ³•å¯åŠ¨ã€‚è¯·å®‰è£… PyQt5ï¼špip install PyQt5")
        print("ä»å¯å¯¼å…¥å¹¶ä½¿ç”¨ clean_one_image å‡½æ•°è¿›è¡Œè„šæœ¬åŒ–æ¸…ç†ã€‚")
        return
    
    app = QApplication(sys.argv)
    window = ClearMetaApp()
    window.show()
    sys.exit(app.exec_())
if __name__ == "__main__":
	main()

